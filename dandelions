//import java.util.Arrays; 
import processing.opengl.*;
import ddf.minim.*;
//import ddf.minim.signals.*;
//import ddf.minim.analysis.*;
//import ddf.minim.effects.*;
import ddf.minim.ugens.*;

Minim minim;
AudioInput in;

AudioOutput out;
Sampler sample;

ParticleSystem dandelion1;
Repeller repeller; //to fix

float seedsx = 0;
float seedsy = 0;

float disappear=6;

boolean noise = false;

//float heart = 20;

//int stalks=600;
//int plant=2000/2;
//int [] stalkheight ={0,stalks-40, stalks-110, stalks-70, stalks-50, stalks-140};
//int [] stalkspread ={0, plant-550, plant-300, plant, plant+300, plant+500};

//float triggerarea = 60;

//int [] rectx = {0,300,200, 340, 1340, 540,1640,740,240,1840,840};
//int [] recty = {0,40, 200, 300, 180, 240, 340, 50, 320, 50, 320, 320};


void setup() {
  size(2000, 600,OPENGL);
  frameRate(50);
  dandelion1 = new ParticleSystem(new PVector(width/2,50));
  systems = new ArrayList<ParticleSystem>();
  repeller = new Repeller (width*0.5+20*sin(frameCount*0.05),height*0.5+20*cos(frameCount*0.05));

  minim = new Minim (this);
  in = minim.getLineIn(Minim.STEREO,512);
  out= minim.getLineOut();
}

void draw() {
background(102);
frameRate(30);

pushStyle();
  stroke(255);
  strokeWeight(2);
  fill(100,0,0);
  popStyle();
  
  //stalk one
  //line(stalkspread[1],height,stalkspread[1],stalkheight[1]+heart/2);
  //ellipse(stalkspread[1], stalkheight[1], heart,heart);
  
  
  //stalk two  
  //line(stalkspread[2],height,stalkspread[2],stalkheight[2]+heart/2);
  //ellipse(stalkspread[2], stalkheight[2], heart,heart);
  
  
  //stalk three 
  //line(stalkspread[3],height,stalkspread[3],stalkheight[3]+heart/2);
  //ellipse(stalkspread[3], stalkheight[3], heart,heart);
  
  //stalk four 
  //line(stalkspread[4],height,stalkspread[4],stalkheight[4]+heart/2);
  //ellipse(stalkspread[4], stalkheight[4], heart,heart);
 
  
  //stalk five 
  //line(stalkspread[5],height,stalkspread[5],stalkheight[5]+heart/2);
  //ellipse(stalkspread[5], stalkheight[5], heart,heart);
  
  
  //noStroke();
  //fill(100,0,0);
  //rect(rectx[1],recty[1],triggerarea,triggerarea);
  //rect(rectx[2],recty[2],triggerarea,triggerarea);
  //rect(rectx[3],recty[3],triggerarea,triggerarea);
  //rect(rectx[4],recty[4],triggerarea,triggerarea);
  //rect(rectx[5],recty[5],triggerarea,triggerarea);
  //rect(rectx[6],recty[6],triggerarea,triggerarea);
  //rect(rectx[7],recty[7],triggerarea,triggerarea);
  //rect(rectx[8],recty[8],triggerarea,triggerarea);
  //rect(rectx[9],recty[9],triggerarea,triggerarea);
  //rect(rectx[10],recty[10],triggerarea,triggerarea);
  
  //float q = 100;
  //for (int i = 0; i <in.bufferSize(); i++){
  //q += abs(in.mix.get(i))*40;
  
    
  pushMatrix();
  translate(width*0.5+20*sin(frameCount*0.05), height*0.5+20*cos(frameCount*0.05));
  //rotate(frameCount / -100.0);
  //scale(1+0.3*sin(frameCount*0.05));
  polygon(0, 0, 70, 20);
  popMatrix();
  line(width*0.5+20*sin(frameCount*0.05),height*0.5+20*cos(frameCount*0.05),width/2,height);
  
  dandelion1.applyRepeller(repeller);
  repeller.display(); 
  
  float sound = 1;
  for (int i = 0; i <in.bufferSize(); i++){
    sound += abs(in.mix.get(i))*120;
    print(in.mix.get(i));
    println("volume");
    if (sound>360){
    noise=true;
    }
    else{
    noise=false;
    }
  }
  }
  
  void polygon(float x, float y, float radius, int npoints) {
  float angle = TWO_PI / npoints;
  beginShape();
  for (float a = 0; a < TWO_PI; a += angle) {
    seedsx = x + cos(a) * radius;
    seedsy = y + sin(a) * radius;
    
    pushStyle();
    noStroke();
    ellipse (seedsx,seedsy,disappear,disappear);
    popStyle();
    line(0,0,seedsx,seedsy);
    
    //repeller.position.set(0,0);
        
    if (noise==true){
    disappear =0;
    dandelion1.origin.set(seedsx, seedsy);
    dandelion1.addParticle();
    dandelion1.run();
    }
    else{
      disappear=6;
    }
  }
  endShape(CLOSE);
 }
